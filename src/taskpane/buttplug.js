(function(o,O){typeof exports=="object"&&typeof module<"u"?O(exports):typeof define=="function"&&define.amd?define(["exports"],O):(o=typeof globalThis<"u"?globalThis:o||self,O(o.buttplug={}))})(this,function(o){"use strict";var ce=Object.defineProperty;var le=(o,O,b)=>O in o?ce(o,O,{enumerable:!0,configurable:!0,writable:!0,value:b}):o[O]=b;var i=(o,O,b)=>le(o,typeof O!="symbol"?O+"":O,b);function O(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var b={exports:{}};(function(n){var s=Object.prototype.hasOwnProperty,e="~";function t(){}Object.create&&(t.prototype=Object.create(null),new t().__proto__||(e=!1));function r(g,u,c){this.fn=g,this.context=u,this.once=c||!1}function d(g,u,c,l,I){if(typeof c!="function")throw new TypeError("The listener must be a function");var v=new r(c,l||g,I),f=e?e+u:u;return g._events[f]?g._events[f].fn?g._events[f]=[g._events[f],v]:g._events[f].push(v):(g._events[f]=v,g._eventsCount++),g}function _(g,u){--g._eventsCount===0?g._events=new t:delete g._events[u]}function h(){this._events=new t,this._eventsCount=0}h.prototype.eventNames=function(){var u=[],c,l;if(this._eventsCount===0)return u;for(l in c=this._events)s.call(c,l)&&u.push(e?l.slice(1):l);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(c)):u},h.prototype.listeners=function(u){var c=e?e+u:u,l=this._events[c];if(!l)return[];if(l.fn)return[l.fn];for(var I=0,v=l.length,f=new Array(v);I<v;I++)f[I]=l[I].fn;return f},h.prototype.listenerCount=function(u){var c=e?e+u:u,l=this._events[c];return l?l.fn?1:l.length:0},h.prototype.emit=function(u,c,l,I,v,f){var S=e?e+u:u;if(!this._events[S])return!1;var a=this._events[S],D=arguments.length,x,p;if(a.fn){switch(a.once&&this.removeListener(u,a.fn,void 0,!0),D){case 1:return a.fn.call(a.context),!0;case 2:return a.fn.call(a.context,c),!0;case 3:return a.fn.call(a.context,c,l),!0;case 4:return a.fn.call(a.context,c,l,I),!0;case 5:return a.fn.call(a.context,c,l,I,v),!0;case 6:return a.fn.call(a.context,c,l,I,v,f),!0}for(p=1,x=new Array(D-1);p<D;p++)x[p-1]=arguments[p];a.fn.apply(a.context,x)}else{var ue=a.length,A;for(p=0;p<ue;p++)switch(a[p].once&&this.removeListener(u,a[p].fn,void 0,!0),D){case 1:a[p].fn.call(a[p].context);break;case 2:a[p].fn.call(a[p].context,c);break;case 3:a[p].fn.call(a[p].context,c,l);break;case 4:a[p].fn.call(a[p].context,c,l,I);break;default:if(!x)for(A=1,x=new Array(D-1);A<D;A++)x[A-1]=arguments[A];a[p].fn.apply(a[p].context,x)}}return!0},h.prototype.on=function(u,c,l){return d(this,u,c,l,!1)},h.prototype.once=function(u,c,l){return d(this,u,c,l,!0)},h.prototype.removeListener=function(u,c,l,I){var v=e?e+u:u;if(!this._events[v])return this;if(!c)return _(this,v),this;var f=this._events[v];if(f.fn)f.fn===c&&(!I||f.once)&&(!l||f.context===l)&&_(this,v);else{for(var S=0,a=[],D=f.length;S<D;S++)(f[S].fn!==c||I&&!f[S].once||l&&f[S].context!==l)&&a.push(f[S]);a.length?this._events[v]=a.length===1?a[0]:a:_(this,v)}return this},h.prototype.removeAllListeners=function(u){var c;return u?(c=e?e+u:u,this._events[c]&&_(this,c)):(this._events=new t,this._eventsCount=0),this},h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,h.prefixed=e,h.EventEmitter=h,n.exports=h})(b);var Z=b.exports;const $=O(Z);/*!
 * Buttplug JS Source Code File - Visit https://buttplug.io for more info about
 * the project. Licensed under the BSD 3-Clause license. See LICENSE file in the
 * project root for full license information.
 *
 * @copyright Copyright (c) Nonpolynomial Labs LLC. All rights reserved.
 */var W=(n=>(n[n.Off=0]="Off",n[n.Error=1]="Error",n[n.Warn=2]="Warn",n[n.Info=3]="Info",n[n.Debug=4]="Debug",n[n.Trace=5]="Trace",n))(W||{});class U{constructor(s,e){i(this,"timestamp");i(this,"logMessage");i(this,"logLevel");const t=new Date,r=t.getHours(),d=t.getMinutes(),_=t.getSeconds();this.timestamp=`${r}:${d}:${_}`,this.logMessage=s,this.logLevel=e}get Message(){return this.logMessage}get LogLevel(){return this.logLevel}get Timestamp(){return this.timestamp}get FormattedMessage(){return`${W[this.logLevel]} : ${this.timestamp} : ${this.logMessage}`}}const k=class k extends ${constructor(){super();i(this,"maximumConsoleLogLevel",0);i(this,"maximumEventLogLevel",0)}static get Logger(){return k.sLogger===void 0&&(k.sLogger=new k),this.sLogger}get MaximumConsoleLogLevel(){return this.maximumConsoleLogLevel}set MaximumConsoleLogLevel(e){this.maximumConsoleLogLevel=e}get MaximumEventLogLevel(){return this.maximumEventLogLevel}set MaximumEventLogLevel(e){this.maximumEventLogLevel=e}Error(e){this.AddLogMessage(e,1)}Warn(e){this.AddLogMessage(e,2)}Info(e){this.AddLogMessage(e,3)}Debug(e){this.AddLogMessage(e,4)}Trace(e){this.AddLogMessage(e,5)}AddLogMessage(e,t){if(t>this.maximumEventLogLevel&&t>this.maximumConsoleLogLevel)return;const r=new U(e,t);t<=this.maximumConsoleLogLevel&&console.log(r.FormattedMessage),t<=this.maximumEventLogLevel&&this.emit("log",r)}};i(k,"sLogger");let F=k;/*!
 * Buttplug JS Source Code File - Visit https://buttplug.io for more info about
 * the project. Licensed under the BSD 3-Clause license. See LICENSE file in the
 * project root for full license information.
 *
 * @copyright Copyright (c) Nonpolynomial Labs LLC. All rights reserved.
 */class w extends Error{constructor(e,t,r=y,d){super(e);i(this,"errorClass",E.ERROR_UNKNOWN);i(this,"innerError");i(this,"messageId");this.errorClass=t,this.innerError=d,this.messageId=r}get ErrorClass(){return this.errorClass}get InnerError(){return this.innerError}get Id(){return this.messageId}get ErrorMessage(){return{Error:{Id:this.Id,ErrorCode:this.ErrorClass,ErrorMessage:this.message}}}static LogAndError(e,t,r,d=y){return t.Error(r),new e(r,d)}static FromError(e){switch(e.ErrorCode){case E.ERROR_DEVICE:return new C(e.ErrorMessage,e.Id);case E.ERROR_INIT:return new V(e.ErrorMessage,e.Id);case E.ERROR_UNKNOWN:return new H(e.ErrorMessage,e.Id);case E.ERROR_PING:return new j(e.ErrorMessage,e.Id);case E.ERROR_MSG:return new R(e.ErrorMessage,e.Id);default:throw new Error(`Message type ${e.ErrorCode} not handled`)}}}class V extends w{constructor(s,e=y){super(s,E.ERROR_INIT,e)}}class C extends w{constructor(s,e=y){super(s,E.ERROR_DEVICE,e)}}class R extends w{constructor(s,e=y){super(s,E.ERROR_MSG,e)}}class j extends w{constructor(s,e=y){super(s,E.ERROR_PING,e)}}class H extends w{constructor(s,e=y){super(s,E.ERROR_UNKNOWN,e)}}const y=0,ee=1,te=4294967295,q=4,J=0;function G(n){for(let[s,e]of Object.entries(n))if(e!=null)return e.Id;throw new R(`Message ${n} does not have an ID.`)}function K(n,s){for(let[e,t]of Object.entries(n))if(t!=null){t.Id=s;return}throw new R(`Message ${n} does not have an ID.`)}var E=(n=>(n[n.ERROR_UNKNOWN=0]="ERROR_UNKNOWN",n[n.ERROR_INIT=1]="ERROR_INIT",n[n.ERROR_PING=2]="ERROR_PING",n[n.ERROR_MSG=3]="ERROR_MSG",n[n.ERROR_DEVICE=4]="ERROR_DEVICE",n))(E||{}),m=(n=>(n.Unknown="Unknown",n.Vibrate="Vibrate",n.Rotate="Rotate",n.Oscillate="Oscillate",n.Constrict="Constrict",n.Inflate="Inflate",n.Position="Position",n.HwPositionWithDuration="HwPositionWithDuration",n.Temperature="Temperature",n.Spray="Spray",n.Led="Led",n))(m||{}),P=(n=>(n.Unknown="Unknown",n.Battery="Battery",n.RSSI="RSSI",n.Button="Button",n.Pressure="Pressure",n))(P||{}),N=(n=>(n.Read="Read",n.Subscribe="Subscribe",n.Unsubscribe="Unsubscribe",n))(N||{});class se{constructor(s,e,t,r){i(this,"send",async s=>await this._sendClosure(s));i(this,"sendMsgExpectOk",async s=>{const e=await this.send(s);if(e.Ok===void 0)throw e.Error!==void 0?w.FromError(e):new R("Expected Ok or Error, and didn't get either!")});this._deviceIndex=s,this._deviceName=e,this._feature=t,this._sendClosure=r}isOutputValid(s){if(this._feature.Output!==void 0&&!this._feature.Output.hasOwnProperty(s))throw new C(`Feature index ${this._feature.FeatureIndex} does not support type ${s} for device ${this._deviceName}`)}isInputValid(s){if(this._feature.Input!==void 0&&!this._feature.Input.hasOwnProperty(s))throw new C(`Feature index ${this._feature.FeatureIndex} does not support type ${s} for device ${this._deviceName}`)}async sendOutputCmd(s){if(this.isOutputValid(s.outputType),s.value===void 0)throw new C(`${s.outputType} requires value defined`);let e=s.outputType,t;if(e==m.HwPositionWithDuration){if(s.duration===void 0)throw new C("PositionWithDuration requires duration defined");t=s.duration}let r,d=s.value;d.percent===void 0?r=s.value.steps:r=Math.ceil(this._feature.Output[e].Value[1]*d.percent);let _={Value:r,Duration:t},h={};h[e.toString()]=_;let g={OutputCmd:{Id:1,DeviceIndex:this._deviceIndex,FeatureIndex:this._feature.FeatureIndex,Command:h}};await this.sendMsgExpectOk(g)}hasOutput(s){return this._feature.Output!==void 0?this._feature.Output.hasOwnProperty(s.toString()):!1}hasInput(s){return this._feature.Input!==void 0?this._feature.Input.hasOwnProperty(s.toString()):!1}async runOutput(s){if(this._feature.Output!==void 0&&this._feature.Output.hasOwnProperty(s.outputType.toString()))return this.sendOutputCmd(s);throw new C(`Output type ${s.outputType} not supported by feature.`)}async runInput(s,e){this.isInputValid(s);let t=this._feature.Input[s];if(console.log(this._feature.Input),e===N.Unsubscribe&&!t.Command.includes(N.Subscribe)&&!t.Command.includes(e))throw new C(`${s} does not support command ${e}`);let r={InputCmd:{Id:1,DeviceIndex:this._deviceIndex,FeatureIndex:this._feature.FeatureIndex,Type:s,Command:e}};if(e==N.Read){const d=await this.send(r);if(d.InputReading!==void 0)return d.InputReading;throw d.Error!==void 0?w.FromError(d):new R("Expected InputReading or Error, and didn't get either!")}else console.log(`Sending subscribe message: ${JSON.stringify(r)}`),await this.sendMsgExpectOk(r),console.log("Got back ok?")}}class T extends ${constructor(e,t){super();i(this,"_features");i(this,"sendMsgExpectOk",async e=>{const t=await this.send(e);if(t.Ok===void 0&&t.Error!==void 0)throw w.FromError(t)});this._deviceInfo=e,this._sendClosure=t,this._features=new Map(Object.entries(e.DeviceFeatures).map(([r,d])=>[parseInt(r),new se(e.DeviceIndex,e.DeviceName,d,t)]))}get name(){return this._deviceInfo.DeviceName}get displayName(){return this._deviceInfo.DeviceDisplayName}get index(){return this._deviceInfo.DeviceIndex}get messageTimingGap(){return this._deviceInfo.DeviceMessageTimingGap}get features(){return this._features}static fromMsg(e,t){return new T(e,t)}async send(e){return await this._sendClosure(e)}isOutputValid(e,t){if(!this._deviceInfo.DeviceFeatures.hasOwnProperty(e.toString()))throw new C(`Feature index ${e} does not exist for device ${this.name}`);if(this._deviceInfo.DeviceFeatures[e.toString()].Outputs!==void 0&&!this._deviceInfo.DeviceFeatures[e.toString()].Outputs.hasOwnProperty(t))throw new C(`Feature index ${e} does not support type ${t} for device ${this.name}`)}hasOutput(e){return this._features.values().filter(t=>t.hasOutput(e)).toArray().length>0}hasInput(e){return this._features.values().filter(t=>t.hasInput(e)).toArray().length>0}async runOutput(e){let t=[];for(let r of this._features.values())r.hasOutput(e.outputType)&&t.push(r.runOutput(e));if(t.length==0)return Promise.reject(`No features with output type ${e.outputType}`);await Promise.all(t)}async stop(){await this.sendMsgExpectOk({StopCmd:{Id:1,DeviceIndex:this.index,FeatureIndex:void 0,Inputs:!0,Outputs:!0}})}async battery(){for(let e of this._features.values())if(e.hasInput(P.Battery)){let t=await e.runInput(P.Battery,N.Read);if(t===void 0)throw new R("Got incorrect message back.");if(t.Reading[P.Battery]===void 0)throw new R("Got reading with no Battery info.");return t.Reading[P.Battery].Value}throw new C("No battery present on this device.")}emitDisconnected(){this.emit("deviceremoved")}}/*!
 * Buttplug JS Source Code File - Visit https://buttplug.io for more info about
 * the project. Licensed under the BSD 3-Clause license. See LICENSE file in the
 * project root for full license information.
 *
 * @copyright Copyright (c) Nonpolynomial Labs LLC. All rights reserved.
 */class z{constructor(s){i(this,"_counter",1);i(this,"_waitingMsgs",new Map);this._useCounter=s}PrepareOutgoingMessage(s){this._useCounter&&(K(s,this._counter),this._counter+=1);let e,t;const r=new Promise((d,_)=>{e=d,t=_});return this._waitingMsgs.set(G(s),[e,t]),r}ParseIncomingMessages(s){const e=[];for(const t of s){let r=G(t);if(r!==y&&this._waitingMsgs.has(r)){const[d,_]=this._waitingMsgs.get(r);if(t.Error!==void 0){_(w.FromError(t.Error));continue}d(t);continue}else e.push(t)}return e}}/*!
 * Buttplug JS Source Code File - Visit https://buttplug.io for more info about
 * the project. Licensed under the BSD 3-Clause license. See LICENSE file in the
 * project root for full license information.
 *
 * @copyright Copyright (c) Nonpolynomial Labs LLC. All rights reserved.
 */class X extends w{constructor(s){super(s,E.ERROR_UNKNOWN)}}class ne extends ${constructor(e="Generic Buttplug Client"){super();i(this,"_pingTimer",null);i(this,"_connector",null);i(this,"_devices",new Map);i(this,"_clientName");i(this,"_logger",F.Logger);i(this,"_isScanning",!1);i(this,"_sorter",new z(!0));i(this,"connect",async e=>{this._logger.Info(`ButtplugClient: Connecting using ${e.constructor.name}`),await e.connect(),this._connector=e,this._connector.addListener("message",this.parseMessages),this._connector.addListener("disconnect",this.disconnectHandler),await this.initializeConnection()});i(this,"disconnect",async()=>{this._logger.Debug("ButtplugClient: Disconnect called"),this._devices.clear(),this.checkConnector(),await this.shutdownConnection(),await this._connector.disconnect()});i(this,"startScanning",async()=>{this._logger.Debug("ButtplugClient: StartScanning called"),this._isScanning=!0,await this.sendMsgExpectOk({StartScanning:{Id:1}})});i(this,"stopScanning",async()=>{this._logger.Debug("ButtplugClient: StopScanning called"),this._isScanning=!1,await this.sendMsgExpectOk({StopScanning:{Id:1}})});i(this,"stopAllDevices",async()=>{this._logger.Debug("ButtplugClient: StopAllDevices"),await this.sendMsgExpectOk({StopCmd:{Id:1,DeviceIndex:void 0,FeatureIndex:void 0,Inputs:!0,Outputs:!0}})});i(this,"disconnectHandler",()=>{this._logger.Info("ButtplugClient: Disconnect event receieved."),this.emit("disconnect")});i(this,"parseMessages",e=>{const t=this._sorter.ParseIncomingMessages(e);for(const r of t)if(r.DeviceList!==void 0){this.parseDeviceList(r);break}else r.ScanningFinished!==void 0?(this._isScanning=!1,this.emit("scanningfinished",r)):r.InputReading!==void 0?this.emit("inputreading",r):console.log(`Unhandled message: ${r}`)});i(this,"initializeConnection",async()=>{this.checkConnector();const e=await this.sendMessage({RequestServerInfo:{ClientName:this._clientName,Id:1,ProtocolVersionMajor:q,ProtocolVersionMinor:J}});if(e.ServerInfo!==void 0){const t=e;return this._logger.Info(`ButtplugClient: Connected to Server ${t.ServerName}`),t.MaxPingTime,await this.requestDeviceList(),!0}else if(e.Error!==void 0){await this._connector.disconnect();const t=e.Error;throw w.LogAndError(V,this._logger,`Cannot connect to server. ${t.ErrorMessage}`)}return!1});i(this,"parseDeviceList",e=>{for(let[t,r]of Object.entries(e.Devices))if(this._devices.has(r.DeviceIndex))this._logger.Debug(`ButtplugClient: Device already added: ${r}`);else{const d=T.fromMsg(r,this.sendMessageClosure);this._logger.Debug(`ButtplugClient: Adding Device: ${d}`),this._devices.set(r.DeviceIndex,d),this.emit("deviceadded",d)}for(let[t,r]of this._devices.entries())e.Devices.hasOwnProperty(t.toString())||(this._devices.delete(t),this.emit("deviceremoved",r))});i(this,"requestDeviceList",async()=>{this.checkConnector(),this._logger.Debug("ButtplugClient: ReceiveDeviceList called");const e=await this.sendMessage({RequestDeviceList:{Id:1}});this.parseDeviceList(e.DeviceList)});i(this,"shutdownConnection",async()=>{await this.stopAllDevices(),this._pingTimer!==null&&(clearInterval(this._pingTimer),this._pingTimer=null)});i(this,"sendMsgExpectOk",async e=>{const t=await this.sendMessage(e);if(t.Ok===void 0)throw t.Error!==void 0?w.FromError(t):w.LogAndError(R,this._logger,`Message ${t} not handled by SendMsgExpectOk`)});i(this,"sendMessageClosure",async e=>await this.sendMessage(e));this._clientName=e,this._logger.Debug(`ButtplugClient: Client ${e} created.`)}get connected(){return this._connector!==null&&this._connector.Connected}get devices(){return this.checkConnector(),this._devices}get isScanning(){return this._isScanning}async sendMessage(e){this.checkConnector();const t=this._sorter.PrepareOutgoingMessage(e);return await this._connector.send(e),await t}checkConnector(){if(!this.connected)throw new X("ButtplugClient not connected")}}class re extends ${constructor(e){super();i(this,"_ws");i(this,"_websocketConstructor",null);i(this,"connect",async()=>new Promise((e,t)=>{const r=new(this._websocketConstructor??WebSocket)(this._url),d=h=>{t(h)},_=h=>t(h.reason);r.addEventListener("open",async()=>{this._ws=r;try{await this.initialize(),this._ws.addEventListener("message",h=>{this.parseIncomingMessage(h)}),this._ws.removeEventListener("close",_),this._ws.removeEventListener("error",d),this._ws.addEventListener("close",this.disconnect),e()}catch(h){t(h)}}),r.addEventListener("error",d),r.addEventListener("close",_)}));i(this,"disconnect",async()=>{this.Connected&&(this._ws.close(),this._ws=void 0,this.emit("disconnect"))});i(this,"initialize",async()=>Promise.resolve());this._url=e}get Connected(){return this._ws!==void 0}sendMessage(e){if(!this.Connected)throw new Error("ButtplugBrowserWebsocketConnector not connected");this._ws.send("["+JSON.stringify(e)+"]")}parseIncomingMessage(e){if(typeof e.data=="string"){const t=JSON.parse(e.data);this.emit("message",t)}else e.data instanceof Blob}onReaderLoad(e){const t=JSON.parse(e.target.result);this.emit("message",t)}}class Y extends re{constructor(){super(...arguments);i(this,"send",e=>{if(!this.Connected)throw new Error("ButtplugClient not connected");this.sendMessage(e)})}}var ie=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")};class oe extends Y{constructor(){super(...arguments);i(this,"_websocketConstructor",ie.WebSocket)}}class L{constructor(){i(this,"_percent");i(this,"_steps")}get percent(){return this._percent}get steps(){return this._steps}static createSteps(s){let e=new L;return e._steps=s,e}static createPercent(s){if(s<0||s>1)throw new C(`Percent value ${s} is not in the range 0.0 <= x <= 1.0`);let e=new L;return e._percent=s,e}}class B{constructor(s,e,t){this._outputType=s,this._value=e,this._duration=t}get outputType(){return this._outputType}get value(){return this._value}get duration(){return this._duration}}class M{constructor(s){this._outputType=s}steps(s){return new B(this._outputType,L.createSteps(s),void 0)}percent(s){return new B(this._outputType,L.createPercent(s),void 0)}}class Q{steps(s,e){return new B(m.Position,L.createSteps(s),e)}percent(s,e){return new B(m.HwPositionWithDuration,L.createPercent(s),e)}}class ae{constructor(){}static get Vibrate(){return new M(m.Vibrate)}static get Rotate(){return new M(m.Rotate)}static get Oscillate(){return new M(m.Oscillate)}static get Constrict(){return new M(m.Constrict)}static get Inflate(){return new M(m.Inflate)}static get Temperature(){return new M(m.Temperature)}static get Led(){return new M(m.Led)}static get Spray(){return new M(m.Spray)}static get Position(){return new M(m.Position)}static get PositionWithDuration(){return new Q}}o.ButtplugBrowserWebsocketClientConnector=Y,o.ButtplugClient=ne,o.ButtplugClientConnectorException=X,o.ButtplugClientDevice=T,o.ButtplugDeviceError=C,o.ButtplugError=w,o.ButtplugInitError=V,o.ButtplugLogLevel=W,o.ButtplugLogger=F,o.ButtplugMessageError=R,o.ButtplugMessageSorter=z,o.ButtplugNodeWebsocketClientConnector=oe,o.ButtplugPingError=j,o.ButtplugUnknownError=H,o.DEFAULT_MESSAGE_ID=ee,o.DeviceOutput=ae,o.DeviceOutputCommand=B,o.DeviceOutputPositionWithDurationConstructor=Q,o.DeviceOutputValueConstructor=M,o.ErrorClass=E,o.InputCommandType=N,o.InputType=P,o.LogMessage=U,o.MAX_ID=te,o.MESSAGE_SPEC_VERSION_MAJOR=q,o.MESSAGE_SPEC_VERSION_MINOR=J,o.OutputType=m,o.SYSTEM_MESSAGE_ID=y,o.msgId=G,o.setMsgId=K,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
